{"ast":null,"code":"import { Base, WordArray } from './core.js';\nimport { SHA1Algo } from './sha1.js';\nimport { HMAC } from './hmac.js';\n\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\nexport class PBKDF2Algo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(new Base(), {\n      keySize: 128 / 32,\n      hasher: SHA1Algo,\n      iterations: 1\n    }, cfg);\n  }\n\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    // Shortcut\n    const {\n      cfg\n    } = this;\n\n    // Init HMAC\n    const hmac = HMAC.create(cfg.hasher, password);\n\n    // Initial values\n    const derivedKey = WordArray.create();\n    const blockIndex = WordArray.create([0x00000001]);\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const blockIndexWords = blockIndex.words;\n    const {\n      keySize,\n      iterations\n    } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      const block = hmac.update(salt).finalize(blockIndex);\n      hmac.reset();\n\n      // Shortcuts\n      const blockWords = block.words;\n      const blockWordsLength = blockWords.length;\n\n      // Iterations\n      let intermediate = block;\n      for (let i = 1; i < iterations; i += 1) {\n        intermediate = hmac.finalize(intermediate);\n        hmac.reset();\n\n        // Shortcut\n        const intermediateWords = intermediate.words;\n\n        // XOR intermediate with block\n        for (let j = 0; j < blockWordsLength; j += 1) {\n          blockWords[j] ^= intermediateWords[j];\n        }\n      }\n      derivedKey.concat(block);\n      blockIndexWords[0] += 1;\n    }\n    derivedKey.sigBytes = keySize * 4;\n    return derivedKey;\n  }\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt);","map":{"version":3,"names":["Base","WordArray","SHA1Algo","HMAC","PBKDF2Algo","constructor","cfg","Object","assign","keySize","hasher","iterations","compute","password","salt","hmac","create","derivedKey","blockIndex","derivedKeyWords","words","blockIndexWords","length","block","update","finalize","reset","blockWords","blockWordsLength","intermediate","i","intermediateWords","j","concat","sigBytes","PBKDF2"],"sources":["/Users/ryan/Desktop/Arcanum/NFTS/tlatc/node_modules/crypto-es/lib/pbkdf2.js"],"sourcesContent":["import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { SHA1Algo } from './sha1.js';\nimport { HMAC } from './hmac.js';\n\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\nexport class PBKDF2Algo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: SHA1Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    // Shortcut\n    const { cfg } = this;\n\n    // Init HMAC\n    const hmac = HMAC.create(cfg.hasher, password);\n\n    // Initial values\n    const derivedKey = WordArray.create();\n    const blockIndex = WordArray.create([0x00000001]);\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const blockIndexWords = blockIndex.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      const block = hmac.update(salt).finalize(blockIndex);\n      hmac.reset();\n\n      // Shortcuts\n      const blockWords = block.words;\n      const blockWordsLength = blockWords.length;\n\n      // Iterations\n      let intermediate = block;\n      for (let i = 1; i < iterations; i += 1) {\n        intermediate = hmac.finalize(intermediate);\n        hmac.reset();\n\n        // Shortcut\n        const intermediateWords = intermediate.words;\n\n        // XOR intermediate with block\n        for (let j = 0; j < blockWordsLength; j += 1) {\n          blockWords[j] ^= intermediateWords[j];\n        }\n      }\n\n      derivedKey.concat(block);\n      blockIndexWords[0] += 1;\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt);\n"],"mappings":"AAAA,SACEA,IAAI,EACJC,SAAS,QACJ,WAAW;AAClB,SAASC,QAAQ,QAAQ,WAAW;AACpC,SAASC,IAAI,QAAQ,WAAW;;AAEhC;AACA;AACA;AACA,OAAO,MAAMC,UAAU,SAASJ,IAAI,CAAC;EACnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,WAAWA,CAACC,GAAG,EAAE;IACf,KAAK,EAAE;;IAEP;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACA,GAAG,GAAGC,MAAM,CAACC,MAAM,CACtB,IAAIR,IAAI,EAAE,EACV;MACES,OAAO,EAAE,GAAG,GAAG,EAAE;MACjBC,MAAM,EAAER,QAAQ;MAChBS,UAAU,EAAE;IACd,CAAC,EACDL,GAAG,CACJ;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,OAAOA,CAACC,QAAQ,EAAEC,IAAI,EAAE;IACtB;IACA,MAAM;MAAER;IAAI,CAAC,GAAG,IAAI;;IAEpB;IACA,MAAMS,IAAI,GAAGZ,IAAI,CAACa,MAAM,CAACV,GAAG,CAACI,MAAM,EAAEG,QAAQ,CAAC;;IAE9C;IACA,MAAMI,UAAU,GAAGhB,SAAS,CAACe,MAAM,EAAE;IACrC,MAAME,UAAU,GAAGjB,SAAS,CAACe,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC;;IAEjD;IACA,MAAMG,eAAe,GAAGF,UAAU,CAACG,KAAK;IACxC,MAAMC,eAAe,GAAGH,UAAU,CAACE,KAAK;IACxC,MAAM;MAAEX,OAAO;MAAEE;IAAW,CAAC,GAAGL,GAAG;;IAEnC;IACA,OAAOa,eAAe,CAACG,MAAM,GAAGb,OAAO,EAAE;MACvC,MAAMc,KAAK,GAAGR,IAAI,CAACS,MAAM,CAACV,IAAI,CAAC,CAACW,QAAQ,CAACP,UAAU,CAAC;MACpDH,IAAI,CAACW,KAAK,EAAE;;MAEZ;MACA,MAAMC,UAAU,GAAGJ,KAAK,CAACH,KAAK;MAC9B,MAAMQ,gBAAgB,GAAGD,UAAU,CAACL,MAAM;;MAE1C;MACA,IAAIO,YAAY,GAAGN,KAAK;MACxB,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,UAAU,EAAEmB,CAAC,IAAI,CAAC,EAAE;QACtCD,YAAY,GAAGd,IAAI,CAACU,QAAQ,CAACI,YAAY,CAAC;QAC1Cd,IAAI,CAACW,KAAK,EAAE;;QAEZ;QACA,MAAMK,iBAAiB,GAAGF,YAAY,CAACT,KAAK;;QAE5C;QACA,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,gBAAgB,EAAEI,CAAC,IAAI,CAAC,EAAE;UAC5CL,UAAU,CAACK,CAAC,CAAC,IAAID,iBAAiB,CAACC,CAAC,CAAC;QACvC;MACF;MAEAf,UAAU,CAACgB,MAAM,CAACV,KAAK,CAAC;MACxBF,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB;IACAJ,UAAU,CAACiB,QAAQ,GAAGzB,OAAO,GAAG,CAAC;IAEjC,OAAOQ,UAAU;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMkB,MAAM,GAAGA,CAACtB,QAAQ,EAAEC,IAAI,EAAER,GAAG,KAAKF,UAAU,CAACY,MAAM,CAACV,GAAG,CAAC,CAACM,OAAO,CAACC,QAAQ,EAAEC,IAAI,CAAC"},"metadata":{},"sourceType":"module"}