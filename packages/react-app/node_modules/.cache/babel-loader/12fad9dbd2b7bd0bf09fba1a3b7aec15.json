{"ast":null,"code":"/* eslint-disable no-use-before-define */\n\nimport { Base, WordArray, BufferedBlockAlgorithm } from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = key => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      }\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor() {\n    super(...arguments);\n    this.blockSize = 1;\n  }\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n    // Create padding word\n    const paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  }\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign({\n      mode: CBC,\n      padding: Pkcs7\n    }, cfg));\n    this.blockSize = 128 / 32;\n  }\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const {\n      cfg\n    } = this;\n    const {\n      iv,\n      mode\n    } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */{\n        modeCreator = mode.createDecryptor;\n        // Keep at least one block in the buffer for unpadding\n        this._minBufferSize = 1;\n      }\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const {\n      padding\n    } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */{\n        // Process final blocks\n        finalProcessedBlocks = this._process(!!'flush');\n\n        // Unpad data\n        padding.unpad(finalProcessedBlocks);\n      }\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const {\n      ciphertext,\n      salt\n    } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n    return wordArray.toString(Base64);\n  },\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n    return CipherParams.create({\n      ciphertext,\n      salt\n    });\n  }\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(new Base(), {\n  format: OpenSSLFormatter\n});\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({\n      keySize: keySize + ivSize\n    }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({\n      key,\n      iv,\n      salt: _salt\n    });\n  }\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, {\n  kdf: OpenSSLKdf\n});","map":{"version":3,"names":["Base","WordArray","BufferedBlockAlgorithm","Base64","EvpKDFAlgo","Cipher","constructor","xformMode","key","cfg","Object","assign","_xformMode","_key","reset","createEncryptor","create","_ENC_XFORM_MODE","createDecryptor","_DEC_XFORM_MODE","_createHelper","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","message","decrypt","ciphertext","call","_doReset","process","dataUpdate","_append","_process","finalize","finalProcessedData","_doFinalize","keySize","ivSize","StreamCipher","arguments","blockSize","finalProcessedBlocks","BlockCipherMode","cipher","iv","_cipher","_iv","Encryptor","Decryptor","xorBlock","words","offset","_words","block","undefined","_prevBlock","i","CBC","processBlock","encryptBlock","slice","thisBlock","decryptBlock","Pkcs7","pad","data","blockSizeBytes","nPaddingBytes","sigBytes","paddingWord","paddingWords","push","padding","concat","unpad","_data","BlockCipher","mode","modeCreator","_minBufferSize","_mode","__creator","_doProcessBlock","CipherParams","cipherParams","mixIn","toString","formatter","stringify","OpenSSLFormatter","wordArray","salt","parse","openSSLStr","ciphertextWords","splice","_cfg","encryptor","cipherCfg","algorithm","format","_ciphertext","_parse","plaintext","OpenSSLKdf","execute","password","_salt","random","compute","derivedParams","kdf"],"sources":["/Users/ryan/Desktop/Arcanum/NFTS/tlatc2/node_modules/crypto-es/lib/cipher-core.js"],"sourcesContent":["/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}