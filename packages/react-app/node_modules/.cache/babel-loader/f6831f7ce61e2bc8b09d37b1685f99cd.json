{"ast":null,"code":"import { WordArray, Hasher } from './core.js';\nimport { X64Word } from './x64-core.js';\n\n// Constants tables\nconst RHO_OFFSETS = [];\nconst PI_INDEXES = [];\nconst ROUND_CONSTANTS = [];\n\n// Compute Constants\n// Compute rho offset constants\nlet _x = 1;\nlet _y = 0;\nfor (let t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = (t + 1) * (t + 2) / 2 % 64;\n  const newX = _y % 5;\n  const newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n}\n\n// Compute pi index constants\nfor (let x = 0; x < 5; x += 1) {\n  for (let y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;\n  }\n}\n\n// Compute round constants\nlet LFSR = 0x01;\nfor (let i = 0; i < 24; i += 1) {\n  let roundConstantMsw = 0;\n  let roundConstantLsw = 0;\n  for (let j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      const bitPosition = (1 << j) - 1;\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else /* if (bitPosition >= 32) */{\n          roundConstantMsw ^= 1 << bitPosition - 32;\n        }\n    }\n\n    // Compute next LFSR\n    if (LFSR & 0x80) {\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n      LFSR = LFSR << 1 ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n}\n\n// Reusable objects for temporary values\nconst T = [];\nfor (let i = 0; i < 25; i += 1) {\n  T[i] = X64Word.create();\n}\n\n/**\n * SHA-3 hash algorithm.\n */\nexport class SHA3Algo extends Hasher {\n  constructor(cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {number} outputLength\n     *   The desired number of bits in the output hash.\n     *   Only values permitted are: 224, 256, 384, 512.\n     *   Default: 512\n     */\n    super(Object.assign({\n      outputLength: 512\n    }, cfg));\n  }\n  _doReset() {\n    this._state = [];\n    const state = this._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = new X64Word();\n    }\n    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n  }\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const state = this._state;\n    const nBlockSizeLanes = this.blockSize / 2;\n\n    // Absorb\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\n      // Shortcuts\n      let M2i = M[offset + 2 * i];\n      let M2i1 = M[offset + 2 * i + 1];\n\n      // Swap endian\n      M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;\n      M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00;\n\n      // Absorb message into state\n      const lane = state[i];\n      lane.high ^= M2i1;\n      lane.low ^= M2i;\n    }\n\n    // Rounds\n    for (let round = 0; round < 24; round += 1) {\n      // Theta\n      for (let x = 0; x < 5; x += 1) {\n        // Mix column lanes\n        let tMsw = 0;\n        let tLsw = 0;\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          tMsw ^= lane.high;\n          tLsw ^= lane.low;\n        }\n\n        // Temporary values\n        const Tx = T[x];\n        Tx.high = tMsw;\n        Tx.low = tLsw;\n      }\n      for (let x = 0; x < 5; x += 1) {\n        // Shortcuts\n        const Tx4 = T[(x + 4) % 5];\n        const Tx1 = T[(x + 1) % 5];\n        const Tx1Msw = Tx1.high;\n        const Tx1Lsw = Tx1.low;\n\n        // Mix surrounding columns\n        const tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);\n        const tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          lane.high ^= tMsw;\n          lane.low ^= tLsw;\n        }\n      }\n\n      // Rho Pi\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n        let tMsw;\n        let tLsw;\n\n        // Shortcuts\n        const lane = state[laneIndex];\n        const laneMsw = lane.high;\n        const laneLsw = lane.low;\n        const rhoOffset = RHO_OFFSETS[laneIndex];\n\n        // Rotate lanes\n        if (rhoOffset < 32) {\n          tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;\n          tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;\n        } else /* if (rhoOffset >= 32) */{\n            tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;\n            tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;\n          }\n\n        // Transpose lanes\n        const TPiLane = T[PI_INDEXES[laneIndex]];\n        TPiLane.high = tMsw;\n        TPiLane.low = tLsw;\n      }\n\n      // Rho pi at x = y = 0\n      const T0 = T[0];\n      const state0 = state[0];\n      T0.high = state0.high;\n      T0.low = state0.low;\n\n      // Chi\n      for (let x = 0; x < 5; x += 1) {\n        for (let y = 0; y < 5; y += 1) {\n          // Shortcuts\n          const laneIndex = x + 5 * y;\n          const lane = state[laneIndex];\n          const TLane = T[laneIndex];\n          const Tx1Lane = T[(x + 1) % 5 + 5 * y];\n          const Tx2Lane = T[(x + 2) % 5 + 5 * y];\n\n          // Mix rows\n          lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;\n          lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;\n        }\n      }\n\n      // Iota\n      const lane = state[0];\n      const roundConstant = ROUND_CONSTANTS[round];\n      lane.high ^= roundConstant.high;\n      lane.low ^= roundConstant.low;\n    }\n  }\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsLeft = data.sigBytes * 8;\n    const blockSizeBits = this.blockSize * 32;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;\n    dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const state = this._state;\n    const outputLengthBytes = this.cfg.outputLength / 8;\n    const outputLengthLanes = outputLengthBytes / 8;\n\n    // Squeeze\n    const hashWords = [];\n    for (let i = 0; i < outputLengthLanes; i += 1) {\n      // Shortcuts\n      const lane = state[i];\n      let laneMsw = lane.high;\n      let laneLsw = lane.low;\n\n      // Swap endian\n      laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;\n      laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00;\n\n      // Squeeze state to retrieve hash\n      hashWords.push(laneLsw);\n      hashWords.push(laneMsw);\n    }\n\n    // Return final computed hash\n    return new WordArray(hashWords, outputLengthBytes);\n  }\n  clone() {\n    const clone = super.clone.call(this);\n    clone._state = this._state.slice(0);\n    const state = clone._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = state[i].clone();\n    }\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA3('message');\n *     var hash = CryptoJS.SHA3(wordArray);\n */\nexport const SHA3 = Hasher._createHelper(SHA3Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA3(message, key);\n */\nexport const HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);","map":{"version":3,"names":["WordArray","Hasher","X64Word","RHO_OFFSETS","PI_INDEXES","ROUND_CONSTANTS","_x","_y","t","newX","newY","x","y","LFSR","i","roundConstantMsw","roundConstantLsw","j","bitPosition","create","T","SHA3Algo","constructor","cfg","Object","assign","outputLength","_doReset","_state","state","blockSize","_doProcessBlock","M","offset","nBlockSizeLanes","M2i","M2i1","lane","high","low","round","tMsw","tLsw","Tx","Tx4","Tx1","Tx1Msw","Tx1Lsw","laneIndex","laneMsw","laneLsw","rhoOffset","TPiLane","T0","state0","TLane","Tx1Lane","Tx2Lane","roundConstant","_doFinalize","data","_data","dataWords","words","nBitsLeft","sigBytes","blockSizeBits","Math","ceil","length","_process","outputLengthBytes","outputLengthLanes","hashWords","push","clone","call","slice","SHA3","_createHelper","HmacSHA3","_createHmacHelper"],"sources":["/Users/ryan/Desktop/Arcanum/NFTS/tlatc/node_modules/crypto-es/lib/sha3.js"],"sourcesContent":["import {\n  WordArray,\n  Hasher,\n} from './core.js';\nimport { X64Word } from './x64-core.js';\n\n// Constants tables\nconst RHO_OFFSETS = [];\nconst PI_INDEXES = [];\nconst ROUND_CONSTANTS = [];\n\n// Compute Constants\n// Compute rho offset constants\nlet _x = 1;\nlet _y = 0;\nfor (let t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = ((t + 1) * (t + 2) / 2) % 64;\n\n  const newX = _y % 5;\n  const newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n}\n\n// Compute pi index constants\nfor (let x = 0; x < 5; x += 1) {\n  for (let y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n  }\n}\n\n// Compute round constants\nlet LFSR = 0x01;\nfor (let i = 0; i < 24; i += 1) {\n  let roundConstantMsw = 0;\n  let roundConstantLsw = 0;\n\n  for (let j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      const bitPosition = (1 << j) - 1;\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else /* if (bitPosition >= 32) */ {\n        roundConstantMsw ^= 1 << (bitPosition - 32);\n      }\n    }\n\n    // Compute next LFSR\n    if (LFSR & 0x80) {\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n      LFSR = (LFSR << 1) ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n\n  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n}\n\n// Reusable objects for temporary values\nconst T = [];\nfor (let i = 0; i < 25; i += 1) {\n  T[i] = X64Word.create();\n}\n\n/**\n * SHA-3 hash algorithm.\n */\nexport class SHA3Algo extends Hasher {\n  constructor(cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {number} outputLength\n     *   The desired number of bits in the output hash.\n     *   Only values permitted are: 224, 256, 384, 512.\n     *   Default: 512\n     */\n    super(Object.assign(\n      { outputLength: 512 },\n      cfg,\n    ));\n  }\n\n  _doReset() {\n    this._state = [];\n    const state = this._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = new X64Word();\n    }\n\n    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const state = this._state;\n    const nBlockSizeLanes = this.blockSize / 2;\n\n    // Absorb\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\n      // Shortcuts\n      let M2i = M[offset + 2 * i];\n      let M2i1 = M[offset + 2 * i + 1];\n\n      // Swap endian\n      M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff)\n        | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);\n      M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff)\n        | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);\n\n      // Absorb message into state\n      const lane = state[i];\n      lane.high ^= M2i1;\n      lane.low ^= M2i;\n    }\n\n    // Rounds\n    for (let round = 0; round < 24; round += 1) {\n      // Theta\n      for (let x = 0; x < 5; x += 1) {\n        // Mix column lanes\n        let tMsw = 0;\n        let tLsw = 0;\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          tMsw ^= lane.high;\n          tLsw ^= lane.low;\n        }\n\n        // Temporary values\n        const Tx = T[x];\n        Tx.high = tMsw;\n        Tx.low = tLsw;\n      }\n      for (let x = 0; x < 5; x += 1) {\n        // Shortcuts\n        const Tx4 = T[(x + 4) % 5];\n        const Tx1 = T[(x + 1) % 5];\n        const Tx1Msw = Tx1.high;\n        const Tx1Lsw = Tx1.low;\n\n        // Mix surrounding columns\n        const tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n        const tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          lane.high ^= tMsw;\n          lane.low ^= tLsw;\n        }\n      }\n\n      // Rho Pi\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n        let tMsw;\n        let tLsw;\n\n        // Shortcuts\n        const lane = state[laneIndex];\n        const laneMsw = lane.high;\n        const laneLsw = lane.low;\n        const rhoOffset = RHO_OFFSETS[laneIndex];\n\n        // Rotate lanes\n        if (rhoOffset < 32) {\n          tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n          tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n        } else /* if (rhoOffset >= 32) */ {\n          tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n          tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n        }\n\n        // Transpose lanes\n        const TPiLane = T[PI_INDEXES[laneIndex]];\n        TPiLane.high = tMsw;\n        TPiLane.low = tLsw;\n      }\n\n      // Rho pi at x = y = 0\n      const T0 = T[0];\n      const state0 = state[0];\n      T0.high = state0.high;\n      T0.low = state0.low;\n\n      // Chi\n      for (let x = 0; x < 5; x += 1) {\n        for (let y = 0; y < 5; y += 1) {\n          // Shortcuts\n          const laneIndex = x + 5 * y;\n          const lane = state[laneIndex];\n          const TLane = T[laneIndex];\n          const Tx1Lane = T[((x + 1) % 5) + 5 * y];\n          const Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n          // Mix rows\n          lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n          lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\n        }\n      }\n\n      // Iota\n      const lane = state[0];\n      const roundConstant = ROUND_CONSTANTS[round];\n      lane.high ^= roundConstant.high;\n      lane.low ^= roundConstant.low;\n    }\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsLeft = data.sigBytes * 8;\n    const blockSizeBits = this.blockSize * 32;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - (nBitsLeft % 32));\n    dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const state = this._state;\n    const outputLengthBytes = this.cfg.outputLength / 8;\n    const outputLengthLanes = outputLengthBytes / 8;\n\n    // Squeeze\n    const hashWords = [];\n    for (let i = 0; i < outputLengthLanes; i += 1) {\n      // Shortcuts\n      const lane = state[i];\n      let laneMsw = lane.high;\n      let laneLsw = lane.low;\n\n      // Swap endian\n      laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff)\n        | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);\n      laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff)\n        | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);\n\n      // Squeeze state to retrieve hash\n      hashWords.push(laneLsw);\n      hashWords.push(laneMsw);\n    }\n\n    // Return final computed hash\n    return new WordArray(hashWords, outputLengthBytes);\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n\n    clone._state = this._state.slice(0);\n    const state = clone._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = state[i].clone();\n    }\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA3('message');\n *     var hash = CryptoJS.SHA3(wordArray);\n */\nexport const SHA3 = Hasher._createHelper(SHA3Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA3(message, key);\n */\nexport const HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}